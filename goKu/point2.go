//先构建一个Person类型 :
package main

import "fmt"

// *和&的区别 :
// & 是取地址符号 , 即取得某个变量的地址 , 如 ; &a
// *是指针运算符 , 可以表示一个变量是指针类型 , 也可以表示一个指针变量所指向的存储单元 , 也就是这个地址所存储的值 .

// 1. &是取地址符号, 取到Person类型对象的地址

// 2. *可以表示一个变量是指针类型(r是一个指针变量):

// 3. *也可以表示指针类型变量所指向的存储单元 ,也就是这个地址所指向的值

// 4. 查看这个指针变量的地址 , 基本数据类型直接打印地址

// 经常会见到: p . *p , &p 三个符号
// p是一个指针变量的名字，表示此指针变量指向的内存地址，如果使用%p来输出的话，它将是一个16进制数。而*p表示此指针指向的内存地址中存放的内容，一般是一个和指针类型一致的变量或者常量。
// 而我们知道，&是取地址运算符，&p就是取指针p的地址。等会，怎么又来了个地址，它到底和p有什么区别？区别在于，指针p同时也是个变量，既然是变量，编译器肯定要为其分配内存地址，
// 就像程序中定义了一个int型的变量i，编译器要为其分配一块内存空间一样。而&p就表示编译器为变量p分配的内存地址，而因为p是一个指针变量，这种特殊的身份注定了它要指向另外一个内存地址，
// 程序员按照程序的需要让它指向一个内存地址，这个它指向的内存地址就用p表示。而且，p指向的地址中的内容就用*p表示。

type Person struct {
	name string
	age  int
}

func (r *Person) hello() string {
	return r.name
}

func main() {
	fmt.Println(&Person{"LC", 10}) // &{LC 10}
	var r = &Person{"LC", 10}
	fmt.Println(r)  // &{LC 10}
	fmt.Println(*r) // {LC 10}
	fmt.Println(&r) // 0xc000006030
	var r2 *Person = &Person{"LC2", 11}
	fmt.Println(r2) // &{LC2 11}
}
